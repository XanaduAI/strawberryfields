# pylint: disable=wrong-import-position,wrong-import-order,ungrouped-imports,invalid-name
r"""
Point Process Tutorial
======================

This tutorial shows how to generate GBS point process samples and use them to detect outlier
points in a data set. Point processes are models for generating random point patterns and GBS
devices can be programmed to operate as special types of point processes that generate clustered
random point patterns.

In GBS point processes, the probability of generating a specific pattern of points depends on
matrix functions of a kernel matrix that describes the similarity between the points. Matrix
functions that appear in GBS point processes are typically permanents and hafnians. In this
tutorial, we use the permanental point process in which the probability of observing a pattern of
points :math:`S` depends on the permanent of their corresponding kernel matrix :math:`K_S` as:

.. math::
    \mathcal{P}(S) = \frac{1}{\alpha(S)}\text{per}(K_S),

where :math:`\alpha` is a normalization function that depends on :math:`S` and the average number
of points.

Let's look at a simple example to better understand the permanental point process.
"""

##############################################################################
# We first import the modules we need:

import numpy as np
import plotly
from sklearn.datasets import make_blobs
from strawberryfields.gbs import points, plot

##############################################################################
# We define a space where the GBS point process patterns are generated. This
# space is referred to as the state space and is defined by a set of points. The
# point process selects a subset of these points in each sample. Here we create
# a 20 :math:`\times` 20 square grid of points.

R = np.array([(i, j) for i in range(20) for j in range(20)])

##############################################################################
# The rows of R are the coordinates of the points.
#
# Next step is to create the kernel matrix for the points of this discrete space. We call
# the :func:`~.kernel` function which uses the *radial basis function* (RBF) kernel defined as:
#
# .. math::
#     K_{i,j} = e^{-\|\bf{r}_i-\bf{r}_j\|^2/2\sigma^2},
#
# where :math:`\bf{r}_i` are the coordinates of point :math:`i` and :math:`\sigma` is a kernel
# parameter that determines the scale of the kernel.
#
# In the RBF kernel, points that are much further than a distance :math:`\sigma` from each other
# lead to small entries of the kernel matrix, whereas points much closer than :math:`\sigma`
# generate large entries. Remember that the permanent of a matrix is a sum over the product of
# some matrix entries. Now consider a specific point pattern in which all points are close to each
# other which simply means that their matrix elements have larger entries. Therefore, the
# submatrix that corresponds to those points has a large permanent and the probability of
# observing them in a sample is larger.
#
# For kernel matrices that are positive-semidefinite, such as the RBF kernel, there exist efficient
# quantum-inspired classical algorithms for permanental point process sampling
# :cite:`jahangiri2019point`. In this tutorial we use positive-semidefinite
# kernels and the quantum-inspired classical algorithm.
#
# Let's construct the RBF kernel with the parameter :math:`\sigma` set to 1.0.

K = points.kernel(R, 1.0)

##############################################################################
# We generate 10 samples with an average number of 40 points per sample by calling
# the :func:`~.points.sample` function of the :mod:`~.gbs.points` module.

samples = points.sample(K, 40.0, 10)

##############################################################################
# We visualize the first sample by using the :func:`~.plot_points` function of
# the :mod:`~.gbs.plot` module. The point patterns generated by the permanental point process
# typically have a higher degree of clustering compared to a uniformly random pattern.

plotly.offline.plot(
    plot.plot_points(R, samples[0], point_size=10), filename="Points.html"
)

##############################################################################
# .. raw:: html
#     :file: ../../examples_gbs/Points.html

##############################################################################
# Outlier Detection
# -----------------
#
# When the distribution of points in a given space is inhomogeneous, GBS point processes typically
# sample points from the dense regions. In a data set containing a uniform grid of points and
# some dense clusters, this feature of the GBS point processes can be used to detect the
# high-density points that can be considered as outliers with respect to the homogeneous
# background. In this example, we create two dense clusters and place them in a two-dimensional
# space containing evenly-distributed points. We show that the permanental point process samples
# points from the dense clusters with a higher probability.
#
# We first create the data points. The clusters have 20 points each and the points have a
# standard deviation of 1 and are centered at [x = 5, y = 5] and [x = 15, y = 15], respectively.
# The grid points are arranged in a 20 :math:`\times` 20 square pattern.

grid = np.array([(i, j) for i in range(20) for j in range(20)])

clusters = make_blobs(n_samples=40, centers=[[5, 5], [15, 15]], cluster_std=1)[0]

R = np.concatenate((clusters, grid))

##############################################################################
# Then construct the kernel matrix and generate 500 samples.

K = points.kernel(R, 1.0)

samples = points.sample(K, 40.0, 500)

##############################################################################
# We obtain the indices of 40 points that appear most frequently in the permanental point
# process samples and then visualize them. The majority of the commonly appearing points belong
# to the dense clusters.

gbs_frequent_points = np.argsort(np.sum(samples, axis=0))[-40:]

plotly.offline.plot(
    plot.plot_points(
        R,
        [1 if i in gbs_frequent_points else 0 for i in range(len(samples[0]))],
        point_size=10,
    ),
    filename="Outliers.html",
)

##############################################################################
# .. raw:: html
#     :file: ../../examples_gbs/Outliers.html
